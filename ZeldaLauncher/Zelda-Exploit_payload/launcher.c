#include "os_types.h"
#include "elf_abi.h"
#include "structs.h"
#include "main_hook.h"
#include "common.h"
void  __attribute__ ((noinline))  setup_syscall(void) ;
void __attribute__ ((noinline)) kern_write(void *addr, uint32_t value);
uint32_t __attribute__ ((noinline)) kern_read(const void *addr);

/* Install functions */
static void InstallMain(private_data_t *private_data);
static void thread_callback(int argc, void *argv);

void KernelWrite(private_data_t *private_data, void * dest, void* src, int len);
extern void SC_KernelMemCpy(void* dest, void* src, uint32_t len);
extern void SC0x09_SetupSyscall();

void registerSyscalls(int syscall, uint32_t func){
    /* set our setup syscall to an unused position */
    kern_write((void*)(KERN_SYSCALL_TBL_1 + (syscall * 4)), func);
    kern_write((void*)(KERN_SYSCALL_TBL_2 + (syscall * 4)), func);
    kern_write((void*)(KERN_SYSCALL_TBL_3 + (syscall * 4)), func);
    kern_write((void*)(KERN_SYSCALL_TBL_4 + (syscall * 4)), func);
    kern_write((void*)(KERN_SYSCALL_TBL_5 + (syscall * 4)), func);
}

/* ****************************************************************** */
/*                               ENTRY POINT                          */
/* ****************************************************************** */
 __attribute__((section (".start"))) int _start(int argc, char ** argv) {   
    unsigned int coreinit_handle;
    OSDynLoad_Acquire("coreinit.rpl", &coreinit_handle);

    /* Get our memory functions */
    unsigned int* functionPointer;
    void* (*p_memset)(void * dest, unsigned int value, unsigned int bytes);
    void  (*_Exit)(int);
    OSDynLoad_FindExport(coreinit_handle, 0, "memset", &p_memset);
    OSDynLoad_FindExport(coreinit_handle, 0, "_Exit", &_Exit);

    private_data_t private_data;
    p_memset(&private_data, 0, sizeof(private_data_t));

    private_data.coreinit_handle = coreinit_handle;
    private_data.memset = p_memset;
    private_data.data_elf = (unsigned char *) main_hook; // use this address as temporary to load the elf

    OSDynLoad_FindExport(coreinit_handle, 1, "MEMAllocFromDefaultHeapEx", &functionPointer);
    private_data.MEMAllocFromDefaultHeapEx = (void*(*)(unsigned int, unsigned int))*functionPointer;
    OSDynLoad_FindExport(coreinit_handle, 1, "MEMFreeToDefaultHeap", &functionPointer);
    private_data.MEMFreeToDefaultHeap = (void (*)(void *))*functionPointer;

    OSDynLoad_FindExport(coreinit_handle, 0, "memcpy", &private_data.memcpy);
    OSDynLoad_FindExport(coreinit_handle, 0, "OSEffectiveToPhysical", &private_data.OSEffectiveToPhysical);
    OSDynLoad_FindExport(coreinit_handle, 0, "DCFlushRange", &private_data.DCFlushRange);
    OSDynLoad_FindExport(coreinit_handle, 0, "ICInvalidateRange", &private_data.ICInvalidateRange);
    OSDynLoad_FindExport(coreinit_handle, 0, "OSEffectiveToPhysical", &private_data.OSEffectiveToPhysical);
    
    unsigned char backupBuffer[0x40];

    uint32_t *targetAddress = (uint32_t*)(0xA0000000 + (0x327FF000 - 0x10000000));
    private_data.memcpy(backupBuffer, targetAddress, sizeof(backupBuffer));

    targetAddress[0] = 0x7c7082a6;                          // mfspr r3, 528
    targetAddress[1] = 0x60630003;                          // ori r3, r3, 0x03
    targetAddress[2] = 0x7c7083a6;                          // mtspr 528, r3
    targetAddress[3] = 0x7c7282a6;                          // mfspr r3, 530
    targetAddress[4] = 0x60630003;                          // ori r3, r3, 0x03
    targetAddress[5] = 0x7c7283a6;                          // mtspr 530, r3
    targetAddress[6] = 0x7c0006ac;                          // eieio
    targetAddress[7] = 0x4c00012c;                          // isync
    targetAddress[8] = 0x3c600000 | (((uint32_t)setup_syscall) >> 16);     // lis r3, setup_syscall@h
    targetAddress[9] = 0x60630000 | (((uint32_t)setup_syscall) & 0xFFFF);  // ori r3, r3, setup_syscall@l
    targetAddress[10] = 0x7c6903a6;                         // mtctr   r3
    targetAddress[11] = 0x4e800420;                         // bctr
    private_data.DCFlushRange(targetAddress, sizeof(backupBuffer));

    uint8_t *hookAddress = (uint8_t*)(0xA0000000 + (0x30000000 - 0x10000000));
    
    uint32_t syscalls[2] = {KERN_CODE_READ, KERN_CODE_WRITE};    
    SC_KernelMemCpy((void *) KERN_SYSCALL_TBL_1 + (0x34 * 4), (void *) syscalls, 8);
    SC_KernelMemCpy((void *) KERN_SYSCALL_TBL_2 + (0x34 * 4), (void *) syscalls, 8);
    SC_KernelMemCpy((void *) KERN_SYSCALL_TBL_3 + (0x34 * 4), (void *)  syscalls, 8);
    SC_KernelMemCpy((void *) KERN_SYSCALL_TBL_4 + (0x34 * 4), (void *) syscalls, 8);
    SC_KernelMemCpy((void *) KERN_SYSCALL_TBL_5 + (0x34 * 4), (void *) syscalls, 8);

    /* set our setup syscall to an unused position */
    registerSyscalls(0x09, 0x017FF000);

    /* run our kernel code :) */
    SC0x09_SetupSyscall();

    /* setup new syscall */
     registerSyscalls(0x09, 0xFFF02344);

    /* repair data */
    private_data.memcpy(targetAddress, backupBuffer, sizeof(backupBuffer));
    private_data.DCFlushRange(targetAddress, sizeof(backupBuffer));

    InstallMain(&private_data);

    Elf32_Ehdr *ehdr = (Elf32_Ehdr *) private_data.data_elf;
    unsigned int mainEntryPoint = ehdr->e_entry;

    //! Install our entry point hook
    unsigned int repl_addr = ADDRESS_main_entry_hook;
    unsigned int jump_addr = mainEntryPoint & 0x03fffffc;

    unsigned int bufferU32 = 0x48000003 | jump_addr;
    KernelWrite(&private_data, (void *) repl_addr, (void *) &bufferU32, 4);

    return ( (int (*)(int, char **))mainEntryPoint)(argc, argv);
}

static int strcmp(const char *s1, const char *s2) {
    while(*s1 && *s2) {
        if(*s1 != *s2) {
            return -1;
        }
        s1++;
        s2++;
    }

    if(*s1 != *s2) {
        return -1;
    }
    return 0;
}

static unsigned int get_section(private_data_t *private_data, unsigned char *data, const char *name, unsigned int * size, unsigned int * addr, int fail_on_not_found) {
    Elf32_Ehdr *ehdr = (Elf32_Ehdr *) data;

    if (   !data
            || !IS_ELF (*ehdr)
            || (ehdr->e_type != ET_EXEC)
            || (ehdr->e_machine != EM_PPC)) {
        OSFatal("Invalid download file!");
    }

    Elf32_Shdr *shdr = (Elf32_Shdr *) (data + ehdr->e_shoff);
    int i;
    for(i = 0; i < ehdr->e_shnum; i++) {
        const char *section_name = ((const char*)data) + shdr[ehdr->e_shstrndx].sh_offset + shdr[i].sh_name;
        if(strcmp(section_name, name) == 0) {
            if(addr)
                *addr = shdr[i].sh_addr;
            if(size)
                *size = shdr[i].sh_size;
            return shdr[i].sh_offset;
        }
    }

    if(fail_on_not_found)
        OSFatal((char*)name);

    return 0;
}

/* ****************************************************************** */
/*                         INSTALL MAIN CODE                          */
/* ****************************************************************** */
static void InstallMain(private_data_t *private_data) {
   // get .text section
    unsigned int main_text_addr = 0;
    unsigned int main_text_len = 0;
    unsigned int section_offset = get_section(private_data, private_data->data_elf, ".text", &main_text_len, &main_text_addr, 1);
    unsigned char *main_text = private_data->data_elf + section_offset;
    /* Copy main .text to memory */
    if(section_offset > 0) {
        KernelWrite(private_data, (void *) (main_text_addr), (void *)main_text, main_text_len);
    }

    // get the .rodata section
    unsigned int main_rodata_addr = 0;
    unsigned int main_rodata_len = 0;
    section_offset = get_section(private_data, private_data->data_elf, ".rodata", &main_rodata_len, &main_rodata_addr, 0);
    if(section_offset > 0) {
        unsigned char *main_rodata = private_data->data_elf + section_offset;
        /* Copy main rodata to memory */
        KernelWrite(private_data, (void *) (main_rodata_addr), (void *)main_rodata, main_rodata_len);
    }

    // get the .data section
    unsigned int main_data_addr = 0;
    unsigned int main_data_len = 0;
    section_offset = get_section(private_data, private_data->data_elf, ".data", &main_data_len, &main_data_addr, 0);
    if(section_offset > 0) {
        unsigned char *main_data = private_data->data_elf + section_offset;
        /* Copy main data to memory */
        KernelWrite(private_data, (void *) (main_data_addr), (void *)main_data, main_data_len);
    }

    // get the .bss section
    unsigned int main_bss_addr = 0;
    unsigned int main_bss_len = 0;
    section_offset = get_section(private_data, private_data->data_elf, ".bss", &main_bss_len, &main_bss_addr, 0);
    if(section_offset > 0) {
        unsigned char *main_bss = private_data->data_elf + section_offset;
        /* Copy main data to memory */
        KernelWrite(private_data, (void *) (main_bss_addr), (void *)main_bss, main_bss_len);
    }
}

/* Read a 32-bit word with kernel permissions */
uint32_t __attribute__ ((noinline)) kern_read(const void *addr) {
    uint32_t result;
    asm volatile (
        "li 3,1\n"
        "li 4,0\n"
        "li 5,0\n"
        "li 6,0\n"
        "li 7,0\n"
        "lis 8,1\n"
        "mr 9,%1\n"
        "li 0,0x3400\n"
        "mr %0,1\n"
        "sc\n"
        "nop\n"
        "mr 1,%0\n"
        "mr %0,3\n"
        :	"=r"(result)
        :	"b"(addr)
        :	"memory", "ctr", "lr", "0", "3", "4", "5", "6", "7", "8", "9", "10",
        "11", "12"
    );

    return result;
}

/* Write a 32-bit word with kernel permissions */
void __attribute__ ((noinline)) kern_write(void *addr, uint32_t value) {
    asm volatile (
        "li 3,1\n"
        "li 4,0\n"
        "mr 5,%1\n"
        "li 6,0\n"
        "li 7,0\n"
        "lis 8,1\n"
        "mr 9,%0\n"
        "mr %1,1\n"
        "li 0,0x3500\n"
        "sc\n"
        "nop\n"
        "mr 1,%1\n"
        :
        :	"r"(addr), "r"(value)
        :	"memory", "ctr", "lr", "0", "3", "4", "5", "6", "7", "8", "9", "10",
        "11", "12"
    );
}

void  __attribute__ ((noinline))  setup_syscall(void) {
    // set kernel code area write permissions
    asm volatile("mtspr 570, %0" : : "r" (0xFFF00002));
    asm volatile("mtspr 571, %0" : : "r" (0xFFF00032));
    asm volatile("eieio; isync");
    
    uint32_t *targetAddress = (uint32_t*)0xFFF02344;
    
    targetAddress[0] = 0x7C0006AC;
    targetAddress[1] = 0x4C00012C;
    targetAddress[2] = 0x7C7083A6;
    targetAddress[3] = 0x7C9183A6;
    targetAddress[4] = 0x7C0006AC;
    targetAddress[5] = 0x4C00012C;
    targetAddress[6] = 0x4E800020;
    
    asm volatile("dcbf 0, %0; icbi 0, %0; sync" : : "r" (0xFFF02344 & ~31));
    asm volatile("dcbf 0, %0; icbi 0, %0; sync" : : "r" ((0xFFF02344 + 0x20) & ~31));
    asm volatile("eieio; isync");
}


void KernelWrite(private_data_t *private_data, void * dest, void* src, int len){
    uint8_t *destAddr = (uint8_t*)(0xA0000000 + (private_data->OSEffectiveToPhysical(dest) - 0x10000000));
    private_data->DCFlushRange(src , len);
    private_data->memcpy(destAddr, src, len);
    private_data->DCFlushRange(dest , len);
    private_data->ICInvalidateRange(dest , len);
}